package ua.tox1cozz.log4j2patcher

import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.ClassWriter.COMPUTE_MAXS
import org.objectweb.asm.Opcodes.*
import org.objectweb.asm.tree.*
import java.nio.file.Files
import java.nio.file.Path

class ClassTransformer(private val patcher: Patcher) {

    fun processClassFile(inFile: Path, outFile: Path): Boolean {
        fun processor(work: (ClassNode) -> Unit) {
            val classData = Files.readAllBytes(inFile)
            val classNode = ClassNode()
            val classReader = ClassReader(classData)
            classReader.accept(classNode, 0)
            work(classNode)
            val writer = ClassWriter(COMPUTE_MAXS/* or COMPUTE_FRAMES*/)
            classNode.accept(writer)
            Files.write(outFile, writer.toByteArray())
        }

        if (inFile.isTargetClass(Patcher.CLASS_JNDI_LOOKUP)) {
            processor { Log4j2.processJndiLookup(it) }
            return true
        } else if (inFile.isTargetClass(Patcher.CLASS_INTERPOLATOR) && patcher.noLookups) {
            processor { Log4j2.processInterpolator(it) }
            return true
        }

        return false
    }

    object Log4j2 {

        private fun patchLookupMethod(classNode: ClassNode, extension: InsnList? = null) {
            val methodName = "lookup"
            val methodDesc = "(Lorg/apache/logging/log4j/core/LogEvent;Ljava/lang/String;)Ljava/lang/String;"

            classNode.methods.filter {
                it.name == methodName && it.desc == methodDesc
            }.forEach { method ->
                method.tryCatchBlocks.clear()
                method.instructions = InsnList().apply {
                    extension?.let { add(it) }
                    add(InsnNode(ACONST_NULL))
                    add(InsnNode(ARETURN))
                }
            }
        }

        fun processJndiLookup(classNode: ClassNode) {
            patchLookupMethod(classNode)
            println("Patched JNDI Lookup exploit in class: ${classNode.name}")
        }

        fun processInterpolator(classNode: ClassNode) {
            val mapField = classNode.fields.find {
                it.desc == "Ljava/util/Map;" && it.signature == "Ljava/util/Map<Ljava/lang/String;Lorg/apache/logging/log4j/core/lookup/StrLookup;>;"
            }

            fun clearMap(): InsnList {
                if (mapField == null) return InsnList()
                return InsnList().apply {
                    add(VarInsnNode(ALOAD, 0))
                    add(FieldInsnNode(GETFIELD, classNode.name, mapField.name, "Ljava/util/Map;"))
                    add(MethodInsnNode(INVOKEINTERFACE, "java/util/Map", "clear", "()V", true))
                }
            }

            // Patch fill lookups map (in constructors)
            classNode.methods.filter {
                it.name == "<init>"
            }.forEach { method ->
                method.instructions.insertBefore(method.instructions.last.previous, clearMap())
            }

            patchLookupMethod(classNode, clearMap())

            println("Patched formatMsgNoLookups in class: ${classNode.name}")
        }
    }
}