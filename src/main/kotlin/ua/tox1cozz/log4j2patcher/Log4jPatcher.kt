package ua.tox1cozz.log4j2patcher

import java.io.File
import java.io.IOException
import java.net.URI
import java.nio.file.*
import java.nio.file.attribute.BasicFileAttributes
import java.util.concurrent.Executors
import java.util.concurrent.Executors.defaultThreadFactory
import java.util.concurrent.TimeUnit
import javax.swing.JFileChooser
import javax.swing.JOptionPane.*
import kotlin.io.path.deleteIfExists
import kotlin.io.path.extension
import kotlin.streams.toList

fun main(args: Array<String>) {
    val console = args.isNotEmpty()

    val rootDir: Path?
    val outputDir: Path?
    if (console) {
        rootDir = Paths.get(args[0])
        outputDir = Paths.get(args[1])
    } else {
        rootDir = chooseDir("Select root directory")
        outputDir = chooseDir("Select output directory")
    }

    if (rootDir != null && outputDir != null) {
        Patcher(console, rootDir, outputDir).start()
    } else {
        if (console) {
            System.err.println("Setup root directory (1 argument) and output directory (2 argument)")
        } else {
            showMessageDialog(
                null,
                "Setup root directory and output directory",
                "Oops!",
                ERROR_MESSAGE
            )
        }
    }
}

fun chooseDir(title: String): Path? {
    val chooser = JFileChooser()
    chooser.currentDirectory = File(".")
    chooser.fileSelectionMode = JFileChooser.DIRECTORIES_ONLY
    chooser.isAcceptAllFileFilterUsed = false
    chooser.dialogTitle = title
    if (chooser.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {
        return chooser.selectedFile.toPath()
    }
    return null
}

class Patcher(
    private val console: Boolean,
    private val rootDir: Path,
    private val outputDir: Path
) {

    companion object {

        const val CLASS_JNDI_LOOKUP = "org/apache/logging/log4j/core/lookup/JndiLookup.class"
        val TARGET_CLASSES = listOf(CLASS_JNDI_LOOKUP)
    }

    fun start() {
        println("Search jars in directory $rootDir")

        val jars = loadJarFiles()
        val log4j2Jars = searchTargetJars(jars)

        if (log4j2Jars.isEmpty()) {
            println("Log4j2 exploits jars not found, aborting")
            return
        }

        println("Found ${jars.size} jars")
        println("Found ${log4j2Jars.size} log4j2 exploits on jars:")
        log4j2Jars.forEach { println(it.file) }

        val jarProcessor = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors() * 2
        ) {
            defaultThreadFactory().newThread(it).apply {
                name = "Jar Processor"
            }
        }

        println("Patching...")
        log4j2Jars.forEach { jarFile ->
            jarProcessor.execute {
                runCatching {
                    processJar(jarFile)
                }.onFailure {
                    System.err.println("Failed to process jar: ${jarFile.file}")
                    it.printStackTrace()
                }
            }
        }

        jarProcessor.shutdown()
        jarProcessor.awaitTermination(10, TimeUnit.MINUTES)

        jars.forEach { it.fileSystem.close() }
        println("Finished")

        "Replace the original files with the patched ones in the output directory".let {
            if (console) {
                println(it)
            } else {
                showMessageDialog(
                    null,
                    it,
                    "Finished",
                    INFORMATION_MESSAGE
                )
            }
        }
    }

    private fun processJar(jarFile: JarFile) {
        val inFileSystem = jarFile.fileSystem
        println("Processing jar: ${jarFile.file}")

        val outputJar = outputDir.resolve(jarFile.file.fileName)
        outputJar.deleteIfExists()
        val outFileSystem = FileSystems.newFileSystem(
            URI.create("jar:${outputJar.toUri()}"), mapOf(
                "create" to "true",
                "encoding" to "UTF-8"
            )
        )

        outFileSystem.use {
            Files.walkFileTree(inFileSystem.getPath("/"), object : FileVisitor<Path> {
                override fun preVisitDirectory(dir: Path?, attrs: BasicFileAttributes?): FileVisitResult {
                    return FileVisitResult.CONTINUE
                }

                override fun visitFile(file: Path, attrs: BasicFileAttributes?): FileVisitResult {
                    val outputFile = outFileSystem.getPath(file.toString())
                    Files.createDirectories(outputFile.parent)
                    if (file.isTargetClass()) {
                        ClassTransformer.processClassFile(file, outputFile)
                    } else {
                        Files.copy(file, outputFile)
                    }
                    return FileVisitResult.CONTINUE
                }

                override fun visitFileFailed(file: Path?, ex: IOException?): FileVisitResult {
                    System.err.println("Failed to process file: $file")
                    ex?.printStackTrace()
                    return FileVisitResult.TERMINATE
                }

                override fun postVisitDirectory(dir: Path?, ex: IOException?): FileVisitResult {
                    return FileVisitResult.CONTINUE
                }
            })
        }

        println("Saving jar to output directory: $outputJar")
    }


    private fun searchTargetJars(
        jars: List<JarFile>
    ): List<JarFile> {
        return jars.filter {
            Files.walk(it.fileSystem.getPath("/")).anyMatch { file ->
                file.isTargetClass()
            }
        }
    }

    private fun loadJarFiles(): List<JarFile> {
        return Files.walk(rootDir)
            .filter { it.extension.equals("jar", ignoreCase = true) }
            .map {
                val zipProps = mapOf(
                    "create" to "false",
                    "encoding" to "UTF-8"
                )
                JarFile(
                    it,
                    FileSystems.newFileSystem(URI.create("jar:${it.toUri()}"), zipProps)
                )
            }
            .toList()
    }

    data class JarFile(val file: Path, val fileSystem: FileSystem)
}