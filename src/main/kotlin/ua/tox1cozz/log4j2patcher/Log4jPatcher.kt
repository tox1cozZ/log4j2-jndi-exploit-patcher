package ua.tox1cozz.log4j2patcher

import java.io.IOException
import java.net.URI
import java.nio.file.*
import java.nio.file.attribute.BasicFileAttributes
import java.util.concurrent.Executors
import java.util.concurrent.Executors.defaultThreadFactory
import java.util.concurrent.TimeUnit
import kotlin.io.path.deleteIfExists
import kotlin.io.path.extension
import kotlin.streams.toList

var consoleMode = false

fun main(args: Array<String>) {
    consoleMode = args.isNotEmpty()

    Thread.currentThread().setUncaughtExceptionHandler { _, exception ->
        showErrorMessage("Program crashed", exception, true)
    }

    val rootDir: Path?
    val outputDir: Path?
    if (consoleMode) {
        rootDir = Paths.get(args[0])
        outputDir = Paths.get(args[1])
    } else {
        rootDir = chooseDir("Select root directory")
        outputDir = chooseDir("Select output directory")
    }

    if (rootDir != null && outputDir != null) {
        Patcher(rootDir, outputDir).start()
    } else {
        showErrorMessage(
            if (consoleMode) {
                "Setup root directory (1 argument) and output directory (2 argument)"
            } else {
                "Setup root directory and output directory"
            }
        )
    }
}

class Patcher(
    private val rootDir: Path,
    private val outputDir: Path
) {

    companion object {

        const val CLASS_JNDI_LOOKUP = "org/apache/logging/log4j/core/lookup/JndiLookup.class"
        val TARGET_CLASSES = listOf(CLASS_JNDI_LOOKUP)
    }

    fun start() {
        println("Search jars in directory $rootDir")

        val jars = loadJarFiles()
        val log4j2Jars = searchTargetJars(jars)

        if (log4j2Jars.isEmpty()) {
            showInfoMessage("Log4j2 exploits jars not found, aborting")
            return
        }

        val exploitJarsMsg = log4j2Jars.joinToString("\n") { it.file.toString() }
        showInfoMessage(
            """
                Found ${jars.size} jars
                Found ${log4j2Jars.size} log4j2 exploits on jars:
                
                $exploitJarsMsg
            """.trimIndent()
        )

        val jarProcessor = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors() * 2
        ) {
            defaultThreadFactory().newThread(it).apply {
                name = "Jar Processor"
            }
        }

        println("Patching...")
        log4j2Jars.forEach { jarFile ->
            jarProcessor.execute {
                runCatching {
                    processJar(jarFile)
                }.onFailure {
                    showErrorMessage(
                        "Failed to process jar:\n${jarFile.file}",
                        it,
                        true
                    )
                }
            }
        }

        jarProcessor.shutdown()
        jarProcessor.awaitTermination(10, TimeUnit.MINUTES)

        jars.forEach { it.fileSystem.close() }
        println("Finished")

        showInfoMessage(
            """
                Replace the original files with the patched ones in the output directory:
                
                $exploitJarsMsg
            """.trimIndent()
        )
    }

    private fun processJar(jarFile: JarFile) {
        val inFileSystem = jarFile.fileSystem
        println("Processing jar: ${jarFile.file}")

        val outputJar = outputDir.resolve(jarFile.file.fileName)
        outputJar.deleteIfExists()
        val outFileSystem = FileSystems.newFileSystem(
            URI.create("jar:${outputJar.toUri()}"), mapOf(
                "create" to "true",
                "encoding" to "UTF-8"
            )
        )

        outFileSystem.use {
            Files.walkFileTree(inFileSystem.getPath("/"), object : FileVisitor<Path> {
                override fun preVisitDirectory(dir: Path?, attrs: BasicFileAttributes?): FileVisitResult {
                    return FileVisitResult.CONTINUE
                }

                override fun visitFile(file: Path, attrs: BasicFileAttributes?): FileVisitResult {
                    val outputFile = outFileSystem.getPath(file.toString())
                    Files.createDirectories(outputFile.parent)
                    if (file.isTargetClass()) {
                        ClassTransformer.processClassFile(file, outputFile)
                    } else {
                        Files.copy(file, outputFile)
                    }
                    return FileVisitResult.CONTINUE
                }

                override fun visitFileFailed(file: Path?, ex: IOException?): FileVisitResult {
                    System.err.println("Failed to process file: $file")
                    ex?.printStackTrace()
                    return FileVisitResult.TERMINATE
                }

                override fun postVisitDirectory(dir: Path?, ex: IOException?): FileVisitResult {
                    return FileVisitResult.CONTINUE
                }
            })
        }

        println("Saving jar to output directory: $outputJar")
    }


    private fun searchTargetJars(
        jars: List<JarFile>
    ): List<JarFile> {
        return jars.filter {
            Files.walk(it.fileSystem.getPath("/")).anyMatch { file ->
                file.isTargetClass()
            }
        }
    }

    private fun loadJarFiles(): List<JarFile> {
        return Files.walk(rootDir)
            .filter { it.extension.equals("jar", ignoreCase = true) }
            .map {
                val zipProps = mapOf(
                    "create" to "false",
                    "encoding" to "UTF-8"
                )
                JarFile(
                    it,
                    FileSystems.newFileSystem(URI.create("jar:${it.toUri()}"), zipProps)
                )
            }
            .toList()
    }

    data class JarFile(val file: Path, val fileSystem: FileSystem)
}